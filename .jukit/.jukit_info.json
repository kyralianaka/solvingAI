{"cmd": "import numpy as np\n\n\nclass solvingAI:\n    def __init__(self):\n        # Number of neurons\n        self.N = 1000\n        # Fraction of excitatory neurons\n        self.e = 0.8\n        # Fraction of null connections\n        self.k = 90\n\n        # Start with ReLu activation function\n        self.activate = lambda x: max(0, x)\n\n        # Integration parameters\n        self.h = 0.05  # step size, 1/s\n        self.T = 5  # total time, sec\n\n        # Weight update parameters\n        self.lr = 0.01  # learning rate\n        self.rho = 1  # target firing rate\n\n    def initialize(self):\n        # Nischal\n        N = self.N\n        k = self.k\n        D = int(self.e * N)\n        w = np.random.rand(N, N)\n\n        sparse_weight_matrix = np.random.rand(N, N)\n        weight_matrix = np.copy(sparse_weight_matrix)\n        rates_0 = np.random.rand(N, 1)\n        # make matrix k percent sparse\n        num_zero_elements = int((k / 100) * N * N)\n        zero_indices = np.random.choice(N * N, num_zero_elements, replace=False)\n        sparse_weight_matrix.flat[zero_indices] = 0\n\n        non_zero_indices = np.transpose(np.nonzero(sparse_weight_matrix[: N - D, N - D :]))\n        non_zero_indices[:, 1] += N - D\n\n        # set the IE weights to zero\n        sparse_weight_matrix[: N - D, N - D :] = 0\n\n        # get indices of non-zero elements that were originally in the top right block\n        self.IEcxns = non_zero_indices\n\n        return sparse_weight_matrix, rates_0, non_zero_indices\n\n    def rate_eqns(self, y, w):\n        return -y + w @ self.activate(y)\n\n    def weight_update(self):\n        # Nischal\n        pass\n\n    def integrate(self, weights_0, rates_0):\n        # Initialize\n        soln = np.zeros((self.n, self.h * self.T + 1))\n        soln[:, 0] = rates_0\n        weights = weights_0\n        weight_traj = np.zeros((len(self.IEcxns), self.T * self.h))\n\n        for i in range(0, self.T):\n            soln[i + 1] = soln[i] + self.rate_eqns(soln[i], weights) * self.h\n\n            # Save the nonzero IE weights before changing them\n            weight_traj[:, i] = weights[self.IEcxns]\n            # Update the weights\n            weights = self.weight_update(weights)\n\n        return soln\n\n    def integrate(self):\n        # Nischal/Kyra\n        pass\n\n    def run_sim(self):\n        weights_0, rates_0 = self.initialize()\n        soln, weights = self.integrate(weights_0, rates_0)\n\n        return soln, weights\n\nei= solvingAI()\nprint(len(ei.initialize()[2]))", "cmd_opts": " --cell_id=NONE -s", "import_complete": 1, "terminal": "nvimterm"}